/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_draw_texture.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abergman <abergman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/12 14:38:39 by abergman          #+#    #+#             */
/*   Updated: 2025/02/14 21:22:43 by abergman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../header/cub3D.h"

/*
Функция `ft_tex_init` инициализирует параметры,
	необходимые для отрисовки текстуры на стене в игре.
	Она принимает указатель на структуру `t_data`, содержащую все данные игры.

	Первым шагом функция определяет координату `wallx`,
			которая представляет собой точку пересечения луча со стеной.Если луч пересек вертикальную стену(значение `side` равно 0 или 1),
			координата `wallx` рассчитывается на основе позиции игрока по оси Y и направления луча по оси Y.В противном случае,
			если луч пересек горизонтальную стену(значение `side` равно 2 или 3),
			координата `wallx` рассчитывается на основе позиции игрока по оси X и направления луча по оси X.Затем значение
		`wallx` уменьшается на целую часть,
			чтобы получить дробную часть координаты.

	Далее функция вычисляет координату `texx`,
			которая представляет собой координату текстуры по оси X.Это значение рассчитывается как произведение `wallx` и ширины текстуры `WIDTH_TEXTURE`,
			округленное до целого числа.Затем функция корректирует значение `texx` в зависимости от направления игрока.Если луч пересек северную или восточную стену(значение `side` равно 0 или 1) и направление игрока по оси X положительное,
			значение `texx` инвертируется.Аналогично,
			если луч пересек южную или западную стену(значение `side` равно 2 или 3) и направление игрока по оси Y отрицательное,
			значение `texx` также инвертируется
				.


	Наконец, функция вычисляет начальную позицию текстуры `texpos`,
			которая представляет собой координату текстуры по оси Y для верхнего пикселя линии.Это значение рассчитывается на основе начальной координаты `start`,
			высоты экрана `HEIGHT`,
			высоты линии `lineh` и шага `step`

	Затем функция вычисляет шаг `step`,
	который представляет собой количество пикселей текстуры,
	соответствующее одному пикселю на экране.Это значение рассчитывается как отношение высоты текстуры `HEIGHT_TEXTURE` к высоте линии `lineh`,
	представляющей стену на экране.

Таким образом,
функция `ft_tex_init` инициализирует все необходимые параметры для корректного отображения текстуры на стене,
обеспечивая правильное позиционирование и масштабирование текстуры в зависимости от положения и направления игрока. */

void	ft_tex_init(t_data *store)
{
	if (store->ray->side == 0 || store->ray->side == 1)
		store->draw->wallx = store->player->y + store->ray->walldist
			* store->ray->raydir_y;
	else
		store->draw->wallx = store->player->x + store->ray->walldist
			* store->ray->raydir_x;
	store->draw->wallx -= floor((store->draw->wallx));
	store->draw->texx = (int)(store->draw->wallx
			* (double)(store->north->width));
	if ((store->ray->side == 0 || store->ray->side == 1)
		&& store->player->dir_x >= 0)
		store->draw->texx = store->north->width - store->draw->texx - 1;
	if ((store->ray->side == 2 || store->ray->side == 3)
		&& store->player->dir_y <= 0)
		store->draw->texx = store->north->width - store->draw->texx - 1;
	store->draw->step = 1.0 * store->north->height / store->draw->lineh;
	store->draw->texpos = (store->ray->start - HEIGHT / 2 + store->draw->lineh
			/ 2) * store->draw->step;
}

/* Функция `ft_draw_sides` отвечает за определение цвета пикселя текстуры,
	который будет отрисован на экране, в зависимости от стороны стены,
	с которой пересекся луч.Она принимает указатель на структуру `t_data`,
	содержащую все данные игры,
	и возвращает значение цвета пикселя в формате `unsigned int`.

	Первым шагом функция объявляет переменную `bin_color`,
	которая будет использоваться для хранения цвета пикселя.Изначально эта переменная устанавливается в 0.

	Далее функция проверяет значение `side` в структуре `ray`,
	чтобы определить, с какой стороны стены пересекся луч.Если `side` равно 0,
		это означает, что луч пересек северную стену,
		и цвет пикселя берется из текстуры,
	хранящейся в `store->north->address`.Координаты пикселя в текстуре рассчитываются как `HEIGHT_TEXTURE
		* store->draw->texy +
	store->draw->texx`.

	Если `side` равно 1,
	это означает, что луч пересек восточную стену,
		и цвет пикселя берется из текстуры,
	хранящейся в `store->east->address`.Координаты пикселя рассчитываются аналогичным образом.

	Если `side` равно 2,
	это означает, что луч пересек южную стену,
		и цвет пикселя берется из текстуры,
	хранящейся в `store->south->address`.

	Если `side` равно 3,
	это означает, что луч пересек западную стену,
		и цвет пикселя берется из текстуры,
	хранящейся в `store->west->address`.

	После определения цвета пикселя функция возвращает значение `bin_color`,
	которое будет использовано для отрисовки текстуры на экране.Таким образом,
		функция `ft_draw_sides` обеспечивает корректное отображение текстур в зависимости от стороны стены,
		с которой пересекся луч.
 */

static unsigned int	ft_draw_sides(t_data *store)
{
	unsigned int	bin_color;

	bin_color = 0;
	if (store->ray->side == 0)
		bin_color = ((unsigned int *)(store->north->address))[store->north->height
			* store->draw->texy + store->draw->texx];
	else if (store->ray->side == 1)
		bin_color = ((unsigned int *)(store->east->address))[store->east->height
			* store->draw->texy + store->draw->texx];
	else if (store->ray->side == 2)
		bin_color = ((unsigned int *)(store->south->address))[store->south->height
			* store->draw->texy + store->draw->texx];
	else if (store->ray->side == 3)
		bin_color = ((unsigned int *)(store->west->address))[store->west->height
			* store->draw->texy + store->draw->texx];
	return (bin_color);
}

/* Функция `ft_draw_texture` отвечает за отрисовку текстуры на экране для текущей вертикальной полосы,
	представленной координатой `x`.Она принимает два аргумента : указатель на структуру `t_data`,
	содержащую все данные игры, и целое число `x`,
	представляющее текущую координату по оси
		X.

	Первым шагом функция объявляет переменные `bin_color` для хранения цвета пикселя и `y` для итерации по вертикальным координатам.
	Затем вызывается функция `ft_tex_init`,
		которая инициализирует параметры текстуры.

	Переменная `y` устанавливается в значение `store->ray->start - 1`,
	чтобы начать цикл с координаты `start`.Цикл `while` проходит по всем вертикальным координатам от `start` до `end`,
	которые были ранее вычислены для текущей полосы.

	Внутри цикла функция проверяет,
	находится ли текущая координата `y` в пределах экрана.Если `y` меньше 0 или больше или равно `HEIGHT`,
	цикл переходит к следующей итерации с помощью `continue`.

	Далее функция проверяет,
	является ли значение `texpos` недопустимым(NaN или бесконечным).Если это так,
		`texpos` устанавливается в 0.0,
	чтобы избежать ошибок в вычислениях.

	Затем вычисляется координата `texy` для текстуры,
	используя значение `texpos` и маску `HEIGHT_TEXTURE - 1`,
		чтобы ограничить координату в пределах высоты текстуры.Значение `texpos` увеличивается на `step`,
	чтобы перейти к следующей строке текстуры.

	Функция `ft_draw_sides` вызывается для получения цвета пикселя текстуры,
	который сохраняется в переменной `bin_color`.Наконец,
	функция `ft_mlx_pixel_put` используется для установки цвета пикселя на экране по координатам `x` и `y`.

	Таким образом,
	функция `ft_draw_texture` отрисовывает текстуру для текущей вертикальной полосы,
		корректно обрабатывая координаты и значения текстуры,
	чтобы обеспечить правильное отображение сцены.
 */

void	ft_draw_texture(t_data *store, int x)
{
	unsigned int	bin_color;
	int				y;

	ft_tex_init(store);
	y = store->ray->start - 1;
	while (++y <= store->ray->end)
	{
		if (y < 0 || y >= HEIGHT)
			continue ;
		if (isnan(store->draw->texpos) || isinf(store->draw->texpos))
			store->draw->texpos = 0.0;
		store->draw->texy = ((int)store->draw->texpos) & (store->north->height
				- 1);
		store->draw->texy = (int)store->draw->texpos & (store->north->height
				- 1);
		store->draw->texpos += store->draw->step;
		bin_color = ft_draw_sides(store);
		ft_mlx_pixel_put(x, y, store->main, bin_color);
	}
}
