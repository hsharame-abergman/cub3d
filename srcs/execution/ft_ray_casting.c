/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ray_casting.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abergman <abergman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/02 15:33:15 by abergman          #+#    #+#             */
/*   Updated: 2025/02/14 22:53:04 by abergman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../header/cub3D.h"

/* Функция `ft_init_drawing` инициализирует параметры,
	необходимые для алгоритма трассировки лучей в игре.
	Она принимает два аргумента: указатель на структуру `t_data`,
	содержащую все данные игры, и целое число `x`,
	представляющее текущую координату по оси X.

Первым шагом функция вычисляет значение `camera`,
	которое используется для определения направления луча.
	Это значение рассчитывается как нормализованная координата X,
	преобразованная в диапазон от
	-1 до 1.

Затем вычисляются компоненты направления луча `raydir_x` и `raydir_y`
	на основе направления игрока (`dir_x` и `dir_y`) и вектора камеры (`vector_x` и `vector_y`),
	умноженного на значение `camera`.

Далее, функция определяет начальные координаты карты (`map_x` и `map_y`),
	которые соответствуют текущему положению игрока,
	округленному до целого числа. Эти координаты используются для определения,
	в какой ячейке карты находится игрок.

После этого вычисляются значения `deltadist_x` и `deltadist_y`,
	которые представляют собой расстояния,
	которые луч проходит между пересечениями с линиями сетки карты по осям X и Y соответственно.
	Эти значения рассчитываются как обратные величины компонентов направления луча и берутся по модулю с помощью функции `fabs`.

Наконец, переменная `hit` инициализируется значением 0, что указывает на то,
	что луч еще не столкнулся с препятствием. Эта переменная будет использоваться в дальнейшем
	для определения момента столкновения луча с объектом на карте.
 */

void	ft_init_drawing(t_data *store, int x)
{
	store->ray->camera = 2 * x / (double)(WIDTH)-1;
	store->ray->raydir_x = store->player->dir_x + store->player->vector_x
		* store->ray->camera;
	store->ray->raydir_y = store->player->dir_y + store->player->vector_y
		* store->ray->camera;
	store->ray->map_x = (int)(store->player->x);
	store->ray->map_y = (int)(store->player->y);
	store->ray->deltadist_x = fabs(1 / store->ray->raydir_x);
	store->ray->deltadist_y = fabs(1 / store->ray->raydir_y);
	store->ray->hit = 0;
}

/* Функция `ft_calculate_step` вычисляет шаги и начальные расстояния для алгоритма трассировки лучей в игре.
Она принимает указатель на структуру `t_data`, содержащую все данные игры.

Первым шагом функция проверяет направление луча по оси X. Если компонент направления луча `raydir_x` меньше нуля,
	это означает,
		что луч движется влево. В этом случае шаг по оси X (`step_x`) устанавливается в
		-1,
	а начальное расстояние до ближайшей вертикальной линии сетки (`sidedist_x`) рассчитывается как расстояние
	от текущей позиции игрока до ближайшей линии сетки,
	умноженное на значение `deltadist_x`, которое представляет собой расстояние,
	которое луч проходит между пересечениями с вертикальными линиями сетки.

Если компонент направления луча `raydir_x` больше или равен нулю, это означает,
	что луч движется вправо. В этом случае шаг по оси X (`step_x`) устанавливается в 1,
	а начальное расстояние до ближайшей вертикальной линии сетки (`sidedist_x`) рассчитывается как расстояние
	от ближайшей линии сетки до текущей позиции игрока,
	умноженное на значение `deltadist_x`.

Аналогично,
	функция проверяет направление луча по оси Y. Если компонент направления луча `raydir_y` меньше нуля,
	это означает,
		что луч движется вверх. В этом случае шаг по оси Y (`step_y`) устанавливается в
		-1,
	а начальное расстояние до ближайшей горизонтальной линии сетки (`sidedist_y`) рассчитывается как расстояние
	от текущей позиции игрока до ближайшей линии сетки,
	умноженное на значение `deltadist_y`, которое представляет собой расстояние,
	которое луч проходит между пересечениями с горизонтальными линиями сетки.

Если компонент направления луча `raydir_y` больше или равен нулю, это означает,
	что луч движется вниз. В этом случае шаг по оси Y (`step_y`) устанавливается в 1,
	а начальное расстояние до ближайшей горизонтальной линии сетки (`sidedist_y`) рассчитывается как расстояние
	от ближайшей линии сетки до текущей позиции игрока,
	умноженное на значение `deltadist_y`.

Таким образом,
	функция `ft_calculate_step` определяет шаги и начальные расстояния для перемещения луча по сетке карты,
	что является важным этапом в алгоритме трассировки лучей.
 */

void	ft_calculate_step(t_data *store)
{
	if (store->ray->raydir_x < 0)
	{
		store->ray->step_x = -1;
		store->ray->sidedist_x = (store->player->x - store->ray->map_x)
			* store->ray->deltadist_x;
	}
	else
	{
		store->ray->step_x = 1;
		store->ray->sidedist_x = (store->ray->map_x + 1.0 - store->player->x)
			* store->ray->deltadist_x;
	}
	if (store->ray->raydir_y < 0)
	{
		store->ray->step_y = -1;
		store->ray->sidedist_y = (store->player->y - store->ray->map_y)
			* store->ray->deltadist_y;
	}
	else
	{
		store->ray->step_y = 1;
		store->ray->sidedist_y = (store->ray->map_y + 1.0 - store->player->y)
			* store->ray->deltadist_y;
	}
}

/* Функция `ft_calculate_distance` вычисляет расстояние до ближайшей стены,
	с которой пересекается луч,
	в игре или графическом приложении. Она принимает указатель на структуру `t_data`,
	содержащую все данные игры.

Первым шагом функция проверяет компоненты направления луча `raydir_x` и `raydir_y`. Если какое-либо из этих значений равно нулю,
	оно устанавливается в небольшое значение (0.0001f),
	чтобы избежать деления на ноль в последующих вычислениях.

Далее функция проверяет,
	с какой стороной стены пересекся луч. Если значение `side` равно 0 или 1,
	это означает,
	что пересечение произошло с вертикальной стеной. В этом случае расстояние `dist` рассчитывается как разница
	между координатой `map_x` и текущей позицией игрока по оси X,
	скорректированная на половину шага по оси X (`step_x`),
	деленная на компонент направления луча `raydir_x`. Затем это расстояние сохраняется в поле `walldist` структуры
	`ray` и берется по модулю с помощью функции `fabs`.

Если значение `side` равно 2 или 3, это означает,
	что пересечение произошло с горизонтальной стеной. В этом случае расстояние `dist` рассчитывается аналогично,
	но с использованием координаты `map_y` и компонента направления луча `raydir_y`. Затем это расстояние также
	сохраняется в поле `walldist` и берется по модулю.

Наконец, функция проверяет,
	чтобы значение `walldist` не было слишком малым. Если оно меньше 0.0001f,
	оно устанавливается в 0.0001f,
	чтобы избежать проблем с дальнейшими вычислениями,
	которые могут возникнуть из-за слишком малого значения.

Таким образом,
	функция `ft_calculate_distance` вычисляет и корректирует расстояние до ближайшей стены,
	обеспечивая корректное выполнение алгоритма трассировки лучей.
 */
void	ft_calculate_distance(t_data *store)
{
	double	dist;

	if (store->ray->raydir_x == 0.0f)
		store->ray->raydir_x = 0.0001f;
	if (store->ray->raydir_y == 0.0f)
		store->ray->raydir_y = 0.0001f;
	if (store->ray->side == 0 || store->ray->side == 1)
	{
		dist = (store->ray->map_x - store->player->x + (1 - store->ray->step_x)
				/ 2) / store->ray->raydir_x;
		store->ray->walldist = fabs(dist);
	}
	else
	{
		dist = (store->ray->map_y - store->player->y + (1 - store->ray->step_y)
				/ 2) / store->ray->raydir_y;
		store->ray->walldist = fabs(dist);
	}
	if (store->ray->walldist < 0.0001f)
		store->ray->walldist = 0.0001f;
}

/*
Функция `ft_dda` реализует алгоритм Digital Differential Analyzer (DDA) для трассировки лучей в игре или графическом приложении.
Она принимает указатель на структуру `t_data`,
	содержащую все данные игры.

Функция использует цикл `while`, который продолжается до тех пор,
	пока переменная `hit` в структуре `ray` не станет равной 1,
	что указывает на столкновение луча с препятствием.

Внутри цикла функция сравнивает значения `sidedist_x` и `sidedist_y`,
	чтобы определить,
	в каком направлении двигаться дальше. Если `sidedist_x` меньше `sidedist_y`,
	это означает,
	что луч пересекает ближайшую вертикальную линию сетки. В этом случае `sidedist_x` увеличивается на значение `deltadist_x`,
	а координата `map_x` изменяется на значение `step_x`. Если `step_x` равно
	-1, это означает, что луч движется влево,
	и переменная `side` устанавливается в 0. Если `step_x` равно 1,
	это означает, что луч движется вправо,
	и переменная `side` устанавливается в 1.

Если `sidedist_y` меньше или равно `sidedist_x`, это означает,
	что луч пересекает ближайшую горизонтальную линию сетки. В этом случае `sidedist_y` увеличивается на значение `deltadist_y`,
	а координата `map_y` изменяется на значение `step_y`. Если `step_y` равно
	-1, это означает, что луч движется вверх,
	и переменная `side` устанавливается в 2. Если `step_y` равно 1,
	это означает, что луч движется вниз,
	и переменная `side` устанавливается в 3.

После каждого шага функция проверяет, достиг ли луч препятствия,
	проверяя значение в массиве `map_grid` по текущим координатам `map_x` и `map_y`. Если значение равно '1',
	это означает, что луч столкнулся с препятствием,
	и переменная `hit` устанавливается в 1, что завершает цикл.

После выхода из цикла вызывается функция `ft_calculate_distance`,
	которая вычисляет расстояние до ближайшей стены,
	с которой пересекся луч. Таким образом,
	функция `ft_dda` выполняет трассировку луча по сетке карты,
	определяя точку пересечения с препятствием и вычисляя расстояние до него.
 */

void	ft_dda(t_data *store)
{
	while (store->ray->hit == 0)
	{
		if (store->ray->sidedist_x < store->ray->sidedist_y)
		{
			store->ray->sidedist_x += store->ray->deltadist_x;
			store->ray->map_x += store->ray->step_x;
			if (store->ray->step_x == -1)
				store->ray->side = 0;
			else if (store->ray->step_x == 1)
				store->ray->side = 1;
		}
		else
		{
			store->ray->sidedist_y += store->ray->deltadist_y;
			store->ray->map_y += store->ray->step_y;
			if (store->ray->step_y == -1)
				store->ray->side = 2;
			else if (store->ray->step_y == 1)
				store->ray->side = 3;
		}
		if (store->map->map_grid[store->ray->map_y][store->ray->map_x] == '1')
			store->ray->hit = 1;
	}
	ft_calculate_distance(store);
}

/*
Функция `ft_calculate_stripe` отвечает за вычисление параметров для отрисовки вертикальной полосы на экране,
	представляющей стену,
	с которой пересекся луч. Она принимает указатель на структуру `t_data`,
	содержащую все данные игры.

Первым шагом функция проверяет значение `walldist`,
	которое представляет собой расстояние до ближайшей стены. Если это значение меньше или равно 0.0001f,
	оно устанавливается в 0.0001f,
	чтобы избежать деления на ноль и слишком малых значений,
	которые могут вызвать ошибки в вычислениях.

Затем функция вычисляет высоту линии `line_height`,
	которая представляет собой высоту стены на экране. Это значение рассчитывается как отношение высоты экрана
	`HEIGHT` к расстоянию до стены `walldist`. Если результат является бесконечным (`isinf(line_height)`)
	или превышает максимальное значение для целого числа (`INT_MAX`),
	высота линии устанавливается равной высоте экрана `HEIGHT`.

Если высота линии находится в допустимых пределах,
	она преобразуется в целое число и сохраняется в поле `lineh` структуры `draw`. Если высота линии превышает высоту экрана,
	она ограничивается значением `HEIGHT`.

Далее функция вычисляет начальную и конечную координаты для отрисовки линии на экране. Начальная координата
`start` рассчитывается как половина высоты экрана минус половина высоты линии. Если это значение меньше нуля,
	оно устанавливается в 0, чтобы линия не выходила за пределы экрана сверху.

Конечная координата `end` рассчитывается как половина высоты экрана плюс половина высоты линии.
Если это значение больше или равно высоте экрана,
	оно устанавливается в `HEIGHT - 1`,
	чтобы линия не выходила за пределы экрана снизу.

Таким образом,
	функция `ft_calculate_stripe` определяет параметры для отрисовки вертикальной полосы,
	представляющей стену, с учетом расстояния до стены и размеров экрана,
	обеспечивая корректное отображение сцены.
 */

void	ft_calculate_stripe(t_data *store)
{
	double	line_height;

	if (store->ray->walldist <= 0.0001f)
	{
		store->ray->walldist = 0.0001f;
	}
	line_height = (double)HEIGHT / store->ray->walldist;
	if (isinf(line_height) || line_height > INT_MAX)
	{
		store->draw->lineh = HEIGHT;
	}
	else
	{
		store->draw->lineh = (int)line_height;
		if (store->draw->lineh > HEIGHT)
			store->draw->lineh = HEIGHT;
	}
	store->ray->start = (HEIGHT / 2) - (store->draw->lineh / 2);
	if (store->ray->start < 0)
		store->ray->start = 0;
	store->ray->end = (HEIGHT / 2) + (store->draw->lineh / 2);
	if (store->ray->end >= HEIGHT)
		store->ray->end = HEIGHT - 1;
}
